var f={JS_EVAL_TYPE_GLOBAL:0,JS_EVAL_TYPE_MODULE:1,JS_EVAL_TYPE_DIRECT:2,JS_EVAL_TYPE_INDIRECT:3,JS_EVAL_TYPE_MASK:3,JS_EVAL_FLAG_STRICT:8,JS_EVAL_FLAG_STRIP:16,JS_EVAL_FLAG_COMPILE_ONLY:32,JS_EVAL_FLAG_BACKTRACE_BARRIER:64},E={BaseObjects:1,Date:2,Eval:4,StringNormalize:8,RegExp:16,RegExpCompiler:32,JSON:64,Proxy:128,MapSet:256,TypedArrays:512,Promise:1024,BigInt:2048,BigFloat:4096,BigDecimal:8192,OperatorOverloading:16384,BignumExt:32768},g={Pending:0,Fulfilled:1,Rejected:2},O=Object.defineProperty,B=(e,t)=>{for(var r in t)O(e,r,{get:t[r],enumerable:!0})};function d(...e){}var N={};B(N,{QuickJSAsyncifyError:()=>J,QuickJSAsyncifySuspended:()=>M,QuickJSEmscriptenModuleError:()=>G,QuickJSMemoryLeakDetected:()=>U,QuickJSNotImplemented:()=>j,QuickJSPromisePending:()=>R,QuickJSUnknownIntrinsic:()=>L,QuickJSUnwrapError:()=>x,QuickJSUseAfterFree:()=>b,QuickJSWrongOwner:()=>H});var x=class extends Error{constructor(e,t){super(String(e)),this.cause=e,this.context=t,this.name="QuickJSUnwrapError"}},H=class extends Error{constructor(){super(...arguments),this.name="QuickJSWrongOwner"}},b=class extends Error{constructor(){super(...arguments),this.name="QuickJSUseAfterFree"}},j=class extends Error{constructor(){super(...arguments),this.name="QuickJSNotImplemented"}},J=class extends Error{constructor(){super(...arguments),this.name="QuickJSAsyncifyError"}},M=class extends Error{constructor(){super(...arguments),this.name="QuickJSAsyncifySuspended"}},U=class extends Error{constructor(){super(...arguments),this.name="QuickJSMemoryLeakDetected"}},G=class extends Error{constructor(){super(...arguments),this.name="QuickJSEmscriptenModuleError"}},L=class extends TypeError{constructor(){super(...arguments),this.name="QuickJSUnknownIntrinsic"}},R=class extends Error{constructor(){super(...arguments),this.name="QuickJSPromisePending"}};function*V(e){return yield e}function $(e){return V(T(e))}var P=V;P.of=$;function C(e,t){return(...r)=>{let i=t.call(e,P,...r);return T(i)}}function z(e,t){let r=t.call(e,P);return T(r)}function T(e){function t(r){return r.done?r.value:r.value instanceof Promise?r.value.then(i=>t(e.next(i)),i=>t(e.throw(i))):t(e.next(r.value))}return t(e.next())}var p=class{[Symbol.dispose](){return this.dispose()}},Q=Symbol.dispose??Symbol.for("Symbol.dispose"),k=p.prototype;k[Q]||(k[Q]=function(){return this.dispose()});var h=class F extends p{constructor(t,r,i,s){super(),this._value=t,this.copier=r,this.disposer=i,this._owner=s,this._alive=!0,this._constructorStack=void 0}get alive(){return this._alive}get value(){return this.assertAlive(),this._value}get owner(){return this._owner}get dupable(){return!!this.copier}dup(){if(this.assertAlive(),!this.copier)throw new Error("Non-dupable lifetime");return new F(this.copier(this._value),this.copier,this.disposer,this._owner)}consume(t){this.assertAlive();let r=t(this);return this.dispose(),r}dispose(){this.assertAlive(),this.disposer&&this.disposer(this._value),this._alive=!1}assertAlive(){if(!this.alive)throw this._constructorStack?new b(`Lifetime not alive
${this._constructorStack}
Lifetime used`):new b("Lifetime not alive")}},m=class extends h{constructor(e,t){super(e,void 0,void 0,t)}get dupable(){return!0}dup(){return this}dispose(){}},A=class extends h{constructor(e,t,r,i){super(e,t,r,i)}dispose(){this._alive=!1}};function _(e,t){let r;try{e.dispose()}catch(i){r=i}if(t&&r)throw Object.assign(t,{message:`${t.message}
 Then, failed to dispose scope: ${r.message}`,disposeError:r}),t;if(t||r)throw t||r}var c=class S extends p{constructor(){super(...arguments),this._disposables=new h(new Set)}static withScope(t){let r=new S,i;try{return t(r)}catch(s){throw i=s,s}finally{_(r,i)}}static withScopeMaybeAsync(t,r){return z(void 0,function*(i){let s=new S,n;try{return yield*i.of(r.call(t,i,s))}catch(o){throw n=o,o}finally{_(s,n)}})}static async withScopeAsync(t){let r=new S,i;try{return await t(r)}catch(s){throw i=s,s}finally{_(r,i)}}manage(t){return this._disposables.value.add(t),t}get alive(){return this._disposables.alive}dispose(){let t=Array.from(this._disposables.value.values()).reverse();for(let r of t)r.alive&&r.dispose();this._disposables.dispose()}},D=class extends p{constructor(e){super(),this.resolve=t=>{this.resolveHandle.alive&&(this.context.unwrapResult(this.context.callFunction(this.resolveHandle,this.context.undefined,t||this.context.undefined)).dispose(),this.disposeResolvers(),this.onSettled())},this.reject=t=>{this.rejectHandle.alive&&(this.context.unwrapResult(this.context.callFunction(this.rejectHandle,this.context.undefined,t||this.context.undefined)).dispose(),this.disposeResolvers(),this.onSettled())},this.dispose=()=>{this.handle.alive&&this.handle.dispose(),this.disposeResolvers()},this.context=e.context,this.owner=e.context.runtime,this.handle=e.promiseHandle,this.settled=new Promise(t=>{this.onSettled=t}),this.resolveHandle=e.resolveHandle,this.rejectHandle=e.rejectHandle}get alive(){return this.handle.alive||this.resolveHandle.alive||this.rejectHandle.alive}disposeResolvers(){this.resolveHandle.alive&&this.resolveHandle.dispose(),this.rejectHandle.alive&&this.rejectHandle.dispose()}},I=class{constructor(e){this.module=e}toPointerArray(e){let t=new Int32Array(e.map(s=>s.value)),r=t.length*t.BYTES_PER_ELEMENT,i=this.module._malloc(r);return new Uint8Array(this.module.HEAPU8.buffer,i,r).set(new Uint8Array(t.buffer)),new h(i,void 0,s=>this.module._free(s))}newMutablePointerArray(e){let t=new Int32Array(new Array(e).fill(0)),r=t.length*t.BYTES_PER_ELEMENT,i=this.module._malloc(r),s=new Int32Array(this.module.HEAPU8.buffer,i,e);return s.set(t),new h({typedArray:s,ptr:i},void 0,n=>this.module._free(n.ptr))}newHeapCharPointer(e){let t=this.module.lengthBytesUTF8(e),r=t+1,i=this.module._malloc(r);return this.module.stringToUTF8(e,i,r),new h({ptr:i,strlen:t},void 0,s=>this.module._free(s.ptr))}newHeapBufferPointer(e){let t=e.byteLength,r=this.module._malloc(t);return this.module.HEAPU8.set(e,r),new h({pointer:r,numBytes:t},void 0,i=>this.module._free(i.pointer))}consumeHeapCharPointer(e){let t=this.module.UTF8ToString(e);return this.module._free(e),t}};function Y(e){if(!e)return 0;let t=0;for(let[r,i]of Object.entries(e)){if(!(r in E))throw new L(r);i&&(t|=E[r])}return t}function K(e){if(typeof e=="number")return e;if(e===void 0)return 0;let{type:t,strict:r,strip:i,compileOnly:s,backtraceBarrier:n}=e,o=0;return t==="global"&&(o|=f.JS_EVAL_TYPE_GLOBAL),t==="module"&&(o|=f.JS_EVAL_TYPE_MODULE),r&&(o|=f.JS_EVAL_FLAG_STRICT),i&&(o|=f.JS_EVAL_FLAG_STRIP),s&&(o|=f.JS_EVAL_FLAG_COMPILE_ONLY),n&&(o|=f.JS_EVAL_FLAG_BACKTRACE_BARRIER),o}function W(...e){let t=[];for(let r of e)r!==void 0&&(t=t.concat(r));return t}var q=class extends I{constructor(e){super(e.module),this.scope=new c,this.copyJSValue=t=>this.ffi.QTS_DupValuePointer(this.ctx.value,t),this.freeJSValue=t=>{this.ffi.QTS_FreeValuePointer(this.ctx.value,t)},e.ownedLifetimes?.forEach(t=>this.scope.manage(t)),this.owner=e.owner,this.module=e.module,this.ffi=e.ffi,this.rt=e.rt,this.ctx=this.scope.manage(e.ctx)}get alive(){return this.scope.alive}dispose(){return this.scope.dispose()}[Symbol.dispose](){return this.dispose()}manage(e){return this.scope.manage(e)}consumeJSCharPointer(e){let t=this.module.UTF8ToString(e);return this.ffi.QTS_FreeCString(this.ctx.value,e),t}heapValueHandle(e){return new h(e,this.copyJSValue,this.freeJSValue,this.owner)}},X=class extends p{constructor(e){super(),this._undefined=void 0,this._null=void 0,this._false=void 0,this._true=void 0,this._global=void 0,this._BigInt=void 0,this.fnNextId=-32768,this.fnMaps=new Map,this.cToHostCallbacks={callFunction:(t,r,i,s,n)=>{if(t!==this.ctx.value)throw new Error("QuickJSContext instance received C -> JS call with mismatched ctx");let o=this.getFunction(n);if(!o)throw new Error(`QuickJSContext had no callback with id ${n}`);return c.withScopeMaybeAsync(this,function*(a,l){let v=l.manage(new A(r,this.memory.copyJSValue,this.memory.freeJSValue,this.runtime)),w=new Array(i);for(let u=0;u<i;u++){let y=this.ffi.QTS_ArgvGetJSValueConstPointer(s,u);w[u]=l.manage(new A(y,this.memory.copyJSValue,this.memory.freeJSValue,this.runtime))}try{let u=yield*a(o.apply(v,w));if(u){if("error"in u&&u.error)throw d("throw error",u.error),u.error;let y=l.manage(u instanceof h?u:u.value);return this.ffi.QTS_DupValuePointer(this.ctx.value,y.value)}return 0}catch(u){return this.errorToHandle(u).consume(y=>this.ffi.QTS_Throw(this.ctx.value,y.value))}})}},this.runtime=e.runtime,this.module=e.module,this.ffi=e.ffi,this.rt=e.rt,this.ctx=e.ctx,this.memory=new q({...e,owner:this.runtime}),e.callbacks.setContextCallbacks(this.ctx.value,this.cToHostCallbacks),this.dump=this.dump.bind(this),this.getString=this.getString.bind(this),this.getNumber=this.getNumber.bind(this),this.resolvePromise=this.resolvePromise.bind(this)}get alive(){return this.memory.alive}dispose(){this.memory.dispose()}get undefined(){if(this._undefined)return this._undefined;let e=this.ffi.QTS_GetUndefined();return this._undefined=new m(e)}get null(){if(this._null)return this._null;let e=this.ffi.QTS_GetNull();return this._null=new m(e)}get true(){if(this._true)return this._true;let e=this.ffi.QTS_GetTrue();return this._true=new m(e)}get false(){if(this._false)return this._false;let e=this.ffi.QTS_GetFalse();return this._false=new m(e)}get global(){if(this._global)return this._global;let e=this.ffi.QTS_GetGlobalObject(this.ctx.value);return this.memory.manage(this.memory.heapValueHandle(e)),this._global=new m(e,this.runtime),this._global}newNumber(e){return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value,e))}newString(e){let t=this.memory.newHeapCharPointer(e).consume(r=>this.ffi.QTS_NewString(this.ctx.value,r.value.ptr));return this.memory.heapValueHandle(t)}newUniqueSymbol(e){let t=(typeof e=="symbol"?e.description:e)??"",r=this.memory.newHeapCharPointer(t).consume(i=>this.ffi.QTS_NewSymbol(this.ctx.value,i.value.ptr,0));return this.memory.heapValueHandle(r)}newSymbolFor(e){let t=(typeof e=="symbol"?e.description:e)??"",r=this.memory.newHeapCharPointer(t).consume(i=>this.ffi.QTS_NewSymbol(this.ctx.value,i.value.ptr,1));return this.memory.heapValueHandle(r)}newBigInt(e){if(!this._BigInt){let i=this.getProp(this.global,"BigInt");this.memory.manage(i),this._BigInt=new m(i.value,this.runtime)}let t=this._BigInt,r=String(e);return this.newString(r).consume(i=>this.unwrapResult(this.callFunction(t,this.undefined,i)))}newObject(e){e&&this.runtime.assertOwned(e);let t=e?this.ffi.QTS_NewObjectProto(this.ctx.value,e.value):this.ffi.QTS_NewObject(this.ctx.value);return this.memory.heapValueHandle(t)}newArray(){let e=this.ffi.QTS_NewArray(this.ctx.value);return this.memory.heapValueHandle(e)}newArrayBuffer(e){let t=new Uint8Array(e),r=this.memory.newHeapBufferPointer(t),i=this.ffi.QTS_NewArrayBuffer(this.ctx.value,r.value.pointer,t.length);return this.memory.heapValueHandle(i)}newPromise(e){let t=c.withScope(r=>{let i=r.manage(this.memory.newMutablePointerArray(2)),s=this.ffi.QTS_NewPromiseCapability(this.ctx.value,i.value.ptr),n=this.memory.heapValueHandle(s),[o,a]=Array.from(i.value.typedArray).map(l=>this.memory.heapValueHandle(l));return new D({context:this,promiseHandle:n,resolveHandle:o,rejectHandle:a})});return e&&typeof e=="function"&&(e=new Promise(e)),e&&Promise.resolve(e).then(t.resolve,r=>r instanceof h?t.reject(r):this.newError(r).consume(t.reject)),t}newFunction(e,t){let r=++this.fnNextId;return this.setFunction(r,t),this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value,r,e))}newError(e){let t=this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));return e&&typeof e=="object"?(e.name!==void 0&&this.newString(e.name).consume(r=>this.setProp(t,"name",r)),e.message!==void 0&&this.newString(e.message).consume(r=>this.setProp(t,"message",r))):typeof e=="string"?this.newString(e).consume(r=>this.setProp(t,"message",r)):e!==void 0&&this.newString(String(e)).consume(r=>this.setProp(t,"message",r)),t}typeof(e){return this.runtime.assertOwned(e),this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value,e.value))}getNumber(e){return this.runtime.assertOwned(e),this.ffi.QTS_GetFloat64(this.ctx.value,e.value)}getString(e){return this.runtime.assertOwned(e),this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value,e.value))}getSymbol(e){this.runtime.assertOwned(e);let t=this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value,e.value));return this.ffi.QTS_IsGlobalSymbol(this.ctx.value,e.value)?Symbol.for(t):Symbol(t)}getBigInt(e){this.runtime.assertOwned(e);let t=this.getString(e);return BigInt(t)}getArrayBuffer(e){this.runtime.assertOwned(e);let t=this.ffi.QTS_GetArrayBufferLength(this.ctx.value,e.value),r=this.ffi.QTS_GetArrayBuffer(this.ctx.value,e.value);if(!r)throw new Error("Couldn't allocate memory to get ArrayBuffer");return new h(this.module.HEAPU8.subarray(r,r+t),void 0,()=>this.module._free(r))}getPromiseState(e){this.runtime.assertOwned(e);let t=this.ffi.QTS_PromiseState(this.ctx.value,e.value);if(t<0)return{type:"fulfilled",value:e,notAPromise:!0};if(t===g.Pending)return{type:"pending",get error(){return new R("Cannot unwrap a pending promise")}};let r=this.ffi.QTS_PromiseResult(this.ctx.value,e.value),i=this.memory.heapValueHandle(r);if(t===g.Fulfilled)return{type:"fulfilled",value:i};if(t===g.Rejected)return{type:"rejected",error:i};throw i.dispose(),new Error(`Unknown JSPromiseStateEnum: ${t}`)}resolvePromise(e){this.runtime.assertOwned(e);let t=c.withScope(r=>{let i=r.manage(this.getProp(this.global,"Promise")),s=r.manage(this.getProp(i,"resolve"));return this.callFunction(s,i,e)});return t.error?Promise.resolve(t):new Promise(r=>{c.withScope(i=>{let s=i.manage(this.newFunction("resolve",l=>{r({value:l&&l.dup()})})),n=i.manage(this.newFunction("reject",l=>{r({error:l&&l.dup()})})),o=i.manage(t.value),a=i.manage(this.getProp(o,"then"));this.unwrapResult(this.callFunction(a,o,s,n)).dispose()})})}getProp(e,t){this.runtime.assertOwned(e);let r=this.borrowPropertyKey(t).consume(i=>this.ffi.QTS_GetProp(this.ctx.value,e.value,i.value));return this.memory.heapValueHandle(r)}setProp(e,t,r){this.runtime.assertOwned(e),this.borrowPropertyKey(t).consume(i=>this.ffi.QTS_SetProp(this.ctx.value,e.value,i.value,r.value))}defineProp(e,t,r){this.runtime.assertOwned(e),c.withScope(i=>{let s=i.manage(this.borrowPropertyKey(t)),n=r.value||this.undefined,o=!!r.configurable,a=!!r.enumerable,l=!!r.value,v=r.get?i.manage(this.newFunction(r.get.name,r.get)):this.undefined,w=r.set?i.manage(this.newFunction(r.set.name,r.set)):this.undefined;this.ffi.QTS_DefineProp(this.ctx.value,e.value,s.value,n.value,v.value,w.value,o,a,l)})}callFunction(e,t,...r){this.runtime.assertOwned(e);let i=this.memory.toPointerArray(r).consume(n=>this.ffi.QTS_Call(this.ctx.value,e.value,t.value,r.length,n.value)),s=this.ffi.QTS_ResolveException(this.ctx.value,i);return s?(this.ffi.QTS_FreeValuePointer(this.ctx.value,i),{error:this.memory.heapValueHandle(s)}):{value:this.memory.heapValueHandle(i)}}evalCode(e,t="eval.js",r){let i=r===void 0?1:0,s=K(r),n=this.memory.newHeapCharPointer(e).consume(a=>this.ffi.QTS_Eval(this.ctx.value,a.value.ptr,a.value.strlen,t,i,s)),o=this.ffi.QTS_ResolveException(this.ctx.value,n);return o?(this.ffi.QTS_FreeValuePointer(this.ctx.value,n),{error:this.memory.heapValueHandle(o)}):{value:this.memory.heapValueHandle(n)}}throw(e){return this.errorToHandle(e).consume(t=>this.ffi.QTS_Throw(this.ctx.value,t.value))}borrowPropertyKey(e){return typeof e=="number"?this.newNumber(e):typeof e=="string"?this.newString(e):new m(e.value,this.runtime)}getMemory(e){if(e===this.rt.value)return this.memory;throw new Error("Private API. Cannot get memory from a different runtime")}dump(e){this.runtime.assertOwned(e);let t=this.typeof(e);if(t==="string")return this.getString(e);if(t==="number")return this.getNumber(e);if(t==="bigint")return this.getBigInt(e);if(t==="undefined")return;if(t==="symbol")return this.getSymbol(e);let r=this.getPromiseState(e);if(r.type==="fulfilled"&&!r.notAPromise)return e.dispose(),{type:r.type,value:r.value.consume(this.dump)};if(r.type==="pending")return e.dispose(),{type:r.type};if(r.type==="rejected")return e.dispose(),{type:r.type,error:r.error.consume(this.dump)};let i=this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value,e.value));try{return JSON.parse(i)}catch{return i}}unwrapResult(e){if(e.error){let t="context"in e.error?e.error.context:this,r=e.error.consume(i=>this.dump(i));if(r&&typeof r=="object"&&typeof r.message=="string"){let{message:i,name:s,stack:n}=r,o=new x(""),a=o.stack;throw typeof s=="string"&&(o.name=r.name),typeof n=="string"&&(o.stack=`${s}: ${i}
${r.stack}Host: ${a}`),Object.assign(o,{cause:r,context:t,message:i}),o}throw new x(r,t)}return e.value}getFunction(e){let t=e>>8,r=this.fnMaps.get(t);if(r)return r.get(e)}setFunction(e,t){let r=e>>8,i=this.fnMaps.get(r);return i||(i=new Map,this.fnMaps.set(r,i)),i.set(e,t)}errorToHandle(e){return e instanceof h?e:this.newError(e)}encodeBinaryJSON(e){let t=this.ffi.QTS_bjson_encode(this.ctx.value,e.value);return this.memory.heapValueHandle(t)}decodeBinaryJSON(e){let t=this.ffi.QTS_bjson_decode(this.ctx.value,e.value);return this.memory.heapValueHandle(t)}},Z=class extends p{constructor(e){super(),this.scope=new c,this.contextMap=new Map,this.cToHostCallbacks={shouldInterrupt:t=>{if(t!==this.rt.value)throw new Error("QuickJSContext instance received C -> JS interrupt with mismatched rt");let r=this.interruptHandler;if(!r)throw new Error("QuickJSContext had no interrupt handler");return r(this)?1:0},loadModuleSource:C(this,function*(t,r,i,s){let n=this.moduleLoader;if(!n)throw new Error("Runtime has no module loader");if(r!==this.rt.value)throw new Error("Runtime pointer mismatch");let o=this.contextMap.get(i)??this.newContext({contextPointer:i});try{let a=yield*t(n(s,o));if(typeof a=="object"&&"error"in a&&a.error)throw d("cToHostLoadModule: loader returned error",a.error),a.error;let l=typeof a=="string"?a:"value"in a?a.value:a;return this.memory.newHeapCharPointer(l).value.ptr}catch(a){return o.throw(a),0}}),normalizeModule:C(this,function*(t,r,i,s,n){let o=this.moduleNormalizer;if(!o)throw new Error("Runtime has no module normalizer");if(r!==this.rt.value)throw new Error("Runtime pointer mismatch");let a=this.contextMap.get(i)??this.newContext({contextPointer:i});try{let l=yield*t(o(s,n,a));if(typeof l=="object"&&"error"in l&&l.error)throw d("cToHostNormalizeModule: normalizer returned error",l.error),l.error;let v=typeof l=="string"?l:l.value;return a.getMemory(this.rt.value).newHeapCharPointer(v).value.ptr}catch(l){return a.throw(l),0}})},e.ownedLifetimes?.forEach(t=>this.scope.manage(t)),this.module=e.module,this.memory=new I(this.module),this.ffi=e.ffi,this.rt=e.rt,this.callbacks=e.callbacks,this.scope.manage(this.rt),this.callbacks.setRuntimeCallbacks(this.rt.value,this.cToHostCallbacks),this.executePendingJobs=this.executePendingJobs.bind(this)}get alive(){return this.scope.alive}dispose(){return this.scope.dispose()}newContext(e={}){let t=Y(e.intrinsics),r=new h(e.contextPointer||this.ffi.QTS_NewContext(this.rt.value,t),void 0,s=>{this.contextMap.delete(s),this.callbacks.deleteContext(s),this.ffi.QTS_FreeContext(s)}),i=new X({module:this.module,ctx:r,ffi:this.ffi,rt:this.rt,ownedLifetimes:e.ownedLifetimes,runtime:this,callbacks:this.callbacks});return this.contextMap.set(r.value,i),i}setModuleLoader(e,t){this.moduleLoader=e,this.moduleNormalizer=t,this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value,this.moduleNormalizer?1:0)}removeModuleLoader(){this.moduleLoader=void 0,this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)}hasPendingJob(){return!!this.ffi.QTS_IsJobPending(this.rt.value)}setInterruptHandler(e){let t=this.interruptHandler;this.interruptHandler=e,t||this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)}removeInterruptHandler(){this.interruptHandler&&(this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value),this.interruptHandler=void 0)}executePendingJobs(e=-1){let t=this.memory.newMutablePointerArray(1),r=this.ffi.QTS_ExecutePendingJob(this.rt.value,e??-1,t.value.ptr),i=t.value.typedArray[0];if(t.dispose(),i===0)return this.ffi.QTS_FreeValuePointerRuntime(this.rt.value,r),{value:0};let s=this.contextMap.get(i)??this.newContext({contextPointer:i}),n=s.getMemory(this.rt.value).heapValueHandle(r);if(s.typeof(n)==="number"){let o=s.getNumber(n);return n.dispose(),{value:o}}else return{error:Object.assign(n,{context:s})}}setMemoryLimit(e){if(e<0&&e!==-1)throw new Error("Cannot set memory limit to negative number. To unset, pass -1");this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value,e)}computeMemoryUsage(){let e=this.getSystemContext().getMemory(this.rt.value);return e.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value,e.ctx.value))}dumpMemoryUsage(){return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))}setMaxStackSize(e){if(e<0)throw new Error("Cannot set memory limit to negative number. To unset, pass 0.");this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value,e)}assertOwned(e){if(e.owner&&e.owner.rt!==this.rt)throw new H(`Handle is not owned by this runtime: ${e.owner.rt.value} != ${this.rt.value}`)}getSystemContext(){return this.context||(this.context=this.scope.manage(this.newContext())),this.context}},ee=class{constructor(e){this.callFunction=e.callFunction,this.shouldInterrupt=e.shouldInterrupt,this.loadModuleSource=e.loadModuleSource,this.normalizeModule=e.normalizeModule}},te=class{constructor(e){this.contextCallbacks=new Map,this.runtimeCallbacks=new Map,this.suspendedCount=0,this.cToHostCallbacks=new ee({callFunction:(t,r,i,s,n,o)=>this.handleAsyncify(t,()=>{try{let a=this.contextCallbacks.get(r);if(!a)throw new Error(`QuickJSContext(ctx = ${r}) not found for C function call "${o}"`);return a.callFunction(r,i,s,n,o)}catch(a){return console.error("[C to host error: returning null]",a),0}}),shouldInterrupt:(t,r)=>this.handleAsyncify(t,()=>{try{let i=this.runtimeCallbacks.get(r);if(!i)throw new Error(`QuickJSRuntime(rt = ${r}) not found for C interrupt`);return i.shouldInterrupt(r)}catch(i){return console.error("[C to host interrupt: returning error]",i),1}}),loadModuleSource:(t,r,i,s)=>this.handleAsyncify(t,()=>{try{let n=this.runtimeCallbacks.get(r);if(!n)throw new Error(`QuickJSRuntime(rt = ${r}) not found for C module loader`);let o=n.loadModuleSource;if(!o)throw new Error(`QuickJSRuntime(rt = ${r}) does not support module loading`);return o(r,i,s)}catch(n){return console.error("[C to host module loader error: returning null]",n),0}}),normalizeModule:(t,r,i,s,n)=>this.handleAsyncify(t,()=>{try{let o=this.runtimeCallbacks.get(r);if(!o)throw new Error(`QuickJSRuntime(rt = ${r}) not found for C module loader`);let a=o.normalizeModule;if(!a)throw new Error(`QuickJSRuntime(rt = ${r}) does not support module loading`);return a(r,i,s,n)}catch(o){return console.error("[C to host module loader error: returning null]",o),0}})}),this.module=e,this.module.callbacks=this.cToHostCallbacks}setRuntimeCallbacks(e,t){this.runtimeCallbacks.set(e,t)}deleteRuntime(e){this.runtimeCallbacks.delete(e)}setContextCallbacks(e,t){this.contextCallbacks.set(e,t)}deleteContext(e){this.contextCallbacks.delete(e)}handleAsyncify(e,t){if(e)return e.handleSleep(i=>{try{let s=t();if(!(s instanceof Promise)){d("asyncify.handleSleep: not suspending:",s),i(s);return}if(this.suspended)throw new J(`Already suspended at: ${this.suspended.stack}
Attempted to suspend at:`);this.suspended=new M(`(${this.suspendedCount++})`),d("asyncify.handleSleep: suspending:",this.suspended),s.then(n=>{this.suspended=void 0,d("asyncify.handleSleep: resolved:",n),i(n)},n=>{d("asyncify.handleSleep: rejected:",n),console.error("QuickJS: cannot handle error in suspended function",n),this.suspended=void 0})}catch(s){throw this.suspended=void 0,s}});let r=t();if(r instanceof Promise)throw new Error("Promise return value not supported in non-asyncify context.");return r}};function re(e,t){t.interruptHandler&&e.setInterruptHandler(t.interruptHandler),t.maxStackSizeBytes!==void 0&&e.setMaxStackSize(t.maxStackSizeBytes),t.memoryLimitBytes!==void 0&&e.setMemoryLimit(t.memoryLimitBytes)}function ie(e,t){t.moduleLoader&&e.setModuleLoader(t.moduleLoader),t.shouldInterrupt&&e.setInterruptHandler(t.shouldInterrupt),t.memoryLimitBytes!==void 0&&e.setMemoryLimit(t.memoryLimitBytes),t.maxStackSizeBytes!==void 0&&e.setMaxStackSize(t.maxStackSizeBytes)}var se=class{constructor(e,t){this.module=e,this.ffi=t,this.callbacks=new te(e)}newRuntime(e={}){let t=new h(this.ffi.QTS_NewRuntime(),void 0,i=>{this.callbacks.deleteRuntime(i),this.ffi.QTS_FreeRuntime(i)}),r=new Z({module:this.module,callbacks:this.callbacks,ffi:this.ffi,rt:t});return re(r,e),e.moduleLoader&&r.setModuleLoader(e.moduleLoader),r}newContext(e={}){let t=this.newRuntime(),r=t.newContext({...e,ownedLifetimes:W(t,e.ownedLifetimes)});return t.context=r,r}evalCode(e,t={}){return c.withScope(r=>{let i=r.manage(this.newContext());ie(i.runtime,t);let s=i.evalCode(e,"eval.js");if(t.memoryLimitBytes!==void 0&&i.runtime.setMemoryLimit(-1),s.error)throw i.dump(r.manage(s.error));return i.dump(r.manage(s.value))})}getWasmMemory(){let e=this.module.quickjsEmscriptenInit?.(()=>{})?.getWasmMemory?.();if(!e)throw new Error("Variant does not support getting WebAssembly.Memory");return e}getFFI(){return this.ffi}};export{te as QuickJSModuleCallbacks,se as QuickJSWASMModule,re as applyBaseRuntimeOptions,ie as applyModuleEvalRuntimeOptions};
